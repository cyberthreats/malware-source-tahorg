;------------------------------------------------------------------------------
;	Get the address of kernel symbol via  get_kernel_syms(2).
;	On success,  returns the kernel address of <symbol_name>.
;	On error zero is returned.
;
; GET_KERNEL_SYMS(2)
; BUGS
;	There  is  no way to indicate the size of the buffer allo
;	cated for table. If symbols have been added to the kernel
;	since  the program queried for the symbol table size, mem
;	ory will be corrupted.
;
get_symbol:	pusha
		mov	edi, [esp + 36] 	; symbol_name

		xor	edx, edx
.strlen:	cmp	byte [edi + edx], 1
		inc	edx
		jnc	.strlen
		dec	edx
		
		xor	eax, eax
		mov	al,  130
		xor	ebx, ebx
		int	80h			; get the number of ksyms
		or	eax, eax
		js	.failed
		
		mov	ecx, eax
		add	eax, 64			; for safety
		shl	eax, 6			; * sizeof(struct kernel_sym)
		mov	ebp, eax

		sub	esp, ebp
		xor	eax, eax
		mov	al,  130
		mov	ebx, esp
		int	80h			; get the kernel symbols
		
.nextsym:	lea	esi, [ebx + 4]
		push	edi
		push	ecx
		mov	ecx, edx
		cld
		rep	cmpsb
		pop	ecx
		pop	edi		
		jz	.found

		push	byte 64
		pop	eax		
		add	ebx, eax
		loop	.nextsym
.failed:	xor	eax, eax
		jmp	short .done
.found:		mov	eax, [ebx]
.done:		add	esp, ebp
		mov	[esp + 0x1c], eax
		popa
		retn	4
;------------------------------------------------------------------------------
;	Get the address of kernel symbol from /boot/System.map file.
;	On success,  returns the kernel address of <symbol_name>. On
;	error zero is returned.
get_symbol_sm:	pusha
		xor	edx, edx
		mov	dl, 0xff
		mov	ebp, [esp + 36]			; symbol_name
		xor	edi, edi			; OFFSET
		sub	esp, edx
		mov	esi, esp			; BUFFER

		call	get_addr
		lea	ebx, [eax + O(name.System_map)]
		push	byte 5
		pop	eax		
		xor	ecx, ecx
		int	0x80				; open
		or	eax, eax
		jns	.open_ok
		jmp	.failed_return
.open_ok:	xchg	eax, ebx

.loop:		push	edx
		push	byte 19
		pop	eax
		mov	ecx, edi
		xor	edx, edx
		int	0x80				; lseek
		pop	edx
		or	eax, eax
		js	.jmp_failed_close
		
		push	byte 3
		pop	eax
		mov	ecx, esi
		int	0x80				; read 255 bytes
		cmp	eax, edx
		jne	.failed_close
		
		mov	ecx, edx
		push	esi
.xstrlen:	lodsb
		cmp	al, 0x0a
		je	.found_0a
		loop	.xstrlen
		pop	esi
.jmp_failed_close:
		jmp	.failed_close
		
.found_0a:	pop	esi
		mov	eax, edx
		sub	eax, ecx
		add	edi, eax
		inc	edi
		sub	eax, 11

		xor	ecx, ecx
.strlen:	cmp	byte [ebp + ecx], 1
		inc	ecx
		jnc	.strlen
		dec	ecx
		cmp	eax, ecx
		jne	.loop
		
		push	esi
		push	edi
		lea	esi, [esi + 11]
		mov	edi, ebp
		mov	ecx, eax
		rep	cmpsb
		pop	edi
		pop	esi		
		jnz	.loop		

		push	byte 8
		pop	ecx
		xor	eax, eax
		xor	ebp, ebp
.s2a_next:	lodsb
		cmp	al, '0'
		jb	.failed_close
		cmp	al, '9'
		jbe	.s2a_c09
		cmp	al, 'a'
		jb	.failed_close
		cmp	al, 'f'
		ja	.failed_close
		sub	al, ('a' - 10)
		jmp	short .s2a_done
.s2a_c09:	sub	al, '0'
.s2a_done:	shl	ebp, 4
		or	ebp, eax
		loop	.s2a_next
		
.close:		push	byte 6
		pop	eax
		int	0x80				; close
		
.return:	add	esp, edx
		mov	[esp + 0x1c], ebp
		popa
		retn	4

.failed_return:	xor	ebp, ebp
		jmp	short .return
.failed_close:	xor	ebp, ebp
		jmp	short .close
;------------------------------------------------------------------------------